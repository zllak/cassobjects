# -*- encoding: utf-8 -*-

"""This class is in charge of creating the column families in Cassandra.

"""

from pycassa.system_manager import *

from cassobjects.models import MetaModel, MetaTimestampedModel, Column, \
                               ModelRelationship, ModelAttribute

# Exception
class BuilderException(Exception):
    """Something went wrong in the Builder"""
    pass

class Builder(object):
    """Create column families based on Models.

    This class is not responsible for the creation of the keyspace.
    It will only creates column families, secondary indexes, and
    "manually" created secondary indexes.

    If a column family is already created, it will not try to override them,
    unless if the `force` keyword is given.

    """
    @classmethod
    def create(cls, *classes, **kwargs):
        """Collect informations about classes
        """
        force = kwargs.get('force', False)

        for klass in classes:
            if isinstance(klass, MetaModel):
                cls._create_metamodel(klass, force)
            elif isinstance(klass, MetaTimestampedModel):
                cls._create_metatimestampedmodel(klass, force)
            else:
                raise BuilderException("%s is not recognized as a cassobjects "
                                       "class" % klass)

    @classmethod
    def _create_metamodel(cls, klass, force):
        """Creates family column for a MetaModel inherited class.

        If the `force` argument is True, it will drop the column family. This
        can be very dangerous, make sure you know what you're doing.
        If a field is listed as an index, creates a Cassandra secondary index.
        A foreign key is also handled as an index.
        Arbitrary connects to the first server found in the class
        ConnectionPool.
        Rely on the CFRegistry object to get the proper list of properties in
        the model.

        """
        cf = klass.__column_family__
        dct = klass.__dict__
        pool = klass.pool
        sys = SystemManager(pool.server_list[0])
        try:
            cfs_keyspace = sys.get_keyspace_column_families(pool.keyspace)
            if cf in cfs_keyspace:
                if not force:
                    return
                # This will destroy all remaining data, make sure you know
                # what you do.
                sys.drop_column_family(pool.keyspace, cf)
            cvclasses = {}
            indexes = {}
            for attr, value in dct.items():
                if not isinstance(value, ModelAttribute):
                    continue
                value = value.prop
                if isinstance(value, Column):
                    name = value.alias or attr
                    if value.index or value.foreign_key or value.unique:
                        indexes[name] = value.col_type
                    cvclasses[name] = value.col_type
                elif isinstance(value, ModelRelationship):
                    cls._create_relationships(klass, value, force)
            # Create column family
            sys.create_column_family(pool.keyspace, cf, super=False,
                                     comparator_type=UTF8_TYPE,
                                     key_validation_class=TIME_UUID_TYPE,
                                     column_validation_classes=cvclasses,
                                     comment="Generated by cassobjects")
            # Create secondary indexes
            for name, value_type in indexes.items():
                sys.create_index(pool.keyspace, cf, name, value_type,
                                 index_name='%s_%s_index' % (cf, name))
        finally:
            sys.close()

    @classmethod
    def _create_metatimestampedmodel(cls, klass, force):
        """
        """
        pass

    @classmethod
    def _create_relationships(cls, klass, rel, force):
        """Checks if the given relationship needs to create a relationship
        table. This is only true for MetaTimestampedModel.

        """
        target_klass = klass.registry.get_class(rel.target)
        if isinstance(target_klass, MetaTimestampedModel):
            cf = "%s_%s" % (klass.__column_family__,
                            target_klass.__column_family__)
            pool = klass.pool
            sys = SystemManager(pool.server_list[0])
            try:
                cfs_keyspace = sys.get_keyspace_column_families(pool.keyspace)
                if cf in cfs_keyspace:
                    if not force:
                        return
                    sys.drop_column_family(pool.keyspace, cf)
                sys.create_column_family(pool.keyspace, cf, super=False,
                                         comparator_type=TIME_UUID_TYPE,
                                         key_validation_class=TIME_UUID_TYPE,
                                         default_validation_class=TIME_UUID_TYPE,
                                         comment="Generated by cassobjects")
            finally:
                sys.close()
